15th july 

 Java : Java is  a  high level programming  
 -> Java is used to develop mobile apps, web apps, desktop apps, games and much more.
 -> it's secure , portab;le ,object oriented ,platform independent


 16th july 

 what is git?
  -> Installations of vs code .
  -> installation of jre and java 
  -> creation of github account
  -> git - used to trck the changes (changes are also called as commit)
  -> github - which is used to store the code 
  -> remote reposistory - github
  -> local reposistory - laptop 

17th july  

 -> installation of extension  pack for java
 -> JVM (java virtual machine )
 -> which is used to convert the bytecode  to machine level code
 -> It follows platform independent rule and portable in nature beacause it follows the wora function.

 ->JRE (java run time environment)
 -> which provides the run platfform the the bycode/javacode.

 ->JDK(java development kit)
 ->provides an application 
 ->contains the various tools.


1st program 

 public - Access modifier
 class - object
 static - no object is required
 void - no return type
 main - main method

 public class Hello 
 {
    Public static  void main(String args[])
    {
        System.out.println("Hello world");
    }
 }

-> JDK - write and run source code
-> JRE - complies the  bytecode
-> JVM - converts byte code to binary code

18th july 
 Running of same hello world program in different platforms to prove Java is a platform independent language 
 ->linux
 ->mac
 ->windows

 Variables : variables are the containers that is used to store the values in it 
 -> mainly variables follows the process of memory allocation
 -> it follows some set of rules such as the varaiable doesnot start with with digit it only starts with charater or underscore.
  ex: Student_id = 244; (which is true)
      3Student_id = 244;(which is false)

  Variables  ->digit
             ->letter
             ->underscore
             ->special digit

  In java we have 2 tpes of variables  
  -> instance variable (no initialization is required and which is return inside class)
  -> Local variable (declariation &  initialization is required and which is return main method)


Data types : Data types generally defines that which type of the variable we need to be stored.

-> primitive data type                                       -> Non primitive data type
 numeric                non numeric                          ->String         
 ->byte   - 1bit        -> char                              ->array
 ->short  - 2bit        -> Boolean                           ->interface
 ->int    - 4bit                                             ->enum
 ->long   - 8bit
 ->float  - 4bit
 ->double - 8bit
The above data type approach is called static type.

Arrays : two type single dimensional array .multi dimensional array .
 single dimension - only one axis ,element is used by index postition.index starts from 0.

 Syntax of array : datatype[] arrayname= new datatype[size];


string  vs string buffer vs string builder
-> Most commonly used object in java is string.
->String vs string buffer
string: string is immutiable in nature (immutabile- cannot be chnaged). need to be stored in variable like s=s.concate("harika").
string buffer :string buffer are mutable in nature(mutabile -can be chnaged).
 methods            string                                         string buffer
foradding          concate                                         append



// == opertors vs equals() method using string
-> == created a 2 objects which take different memory locations.
-> == used for reference purpose only.
-> equals() used the same memory location.and used for content comparision

// == opertors vs equals() method using stringbuffer
-> == created a 2 objects which take different memory locations.
-> == used for reference purpose only.
-> equals() used the same memory locationbut cannot override in string buffer so always false 
-> equals is used for reference comparision.
// output : false  created a 2 objects which take different memory locations
//false  StringBuffer does not override the equals() method from Object


// heap and string constantpool(scp)part-1.
 example : str str = new string("harika");
   here in above example 2 objects are created beacuse of new keyword one oject created in heap area and another one is string name harika it is another object is created in scp also known as method area.
 example : string s="harika";
 here in above example onlu one object is created in method/scp area.

 //importance or Advantage of String constant pool (scp)
  Advantage : Reusebility of an object.
  Disadvanyage : Abnormal  behaviour of mutliple objects pointing to one reference to overcome with immutabile concept in java.
  once you created string object cannot be changed again .


// Additional questions  for interview
Important FARS:

1. why scp concert is available only for, Object but not for StringBuffer?  
Ans : String is mostly used in java  where as string buffer cannit be used it is used once in a while .

2 . why String Objects StringBuffer objects are are immutable where as mutable?
 Ans :mutliple objects pointing to one reference to overcome with immutabile concept in java.
      once you created string object cannot be changed again .because of scp stringis immutabile in nature.
      Stringbuffer : no reusebility of object so mutabile in nature.

3. In addition to String objects any other immutable in java?
 Ans :  Yes, All Wrapper class objects are immutable in java same as Strings.


 // Importance  Constructors of String class 

String s = new String();// Creates an empty Sting Object .
 → String s = new String (String literal);
 → String s = new String (StringBuffer sb)
 → String S = new String (StringBuilder sb)
 → String s = new String(chart[] ch);
 → String s = new String(byte[] b);


// important method of String classes 

char At[] =  String s = new String("Natural Star Nani");
             System.out.println(s.charAt(8));
concat =   String s1 = new String("harika");
           s1=s1.concat("software");

boolean equals = String  str = new String("HARIKA");
           System.out.println(str.equals("harika"));
      
boolean equals ignorecase = String  strs = new String("HARIKA");
                System.out.println(strs.equalsIgnoreCase("harika"));

isEmpty() = String strss = new String("sandeep");//false
            String strss = new String("");//true
            System.out.println(strss.isEmpty());
          
length() =  String strse = new String("sandeep");
            System.out.println(strse.length()); // 7

substring() = String strses = new String("sandeep");
             System.out.println(strses.substring(beignindex,endindex)); // deep

replace() = String strsesg = new String("sandeep");
            System.out.println(strsesg.replace('a','H')); // sHndeep
    
indexof() = String t = "sandeep";
            System.out.println(t.indexOf('d'));//3

lastindexof() = String yo = "sandeep";
               System.out.println(yo.lastIndexOf('n')); // 2
               System.out.println(yo.lastIndexOf('n','p'));//3

toLowercase() = String yom = "SANDEEP";
                System.out.println(yom.toLowerCase()); //sandeep


toUpperCase() = String yomr = "sandeep";
                System.out.println(yomr.toUpperCase()); //SANDEEP 

trim() =       String ram = "   sandeep   ";
              System.out.println(ram.trim()); // sandeep
             
trim().length() = System.out.println(ram.trim().length()); // 7



// constructors of String Buffer.
default inital capacity of string buffer is 16. 
it will increses in the following formula 
capacity expansion Rule = ( cc + 1)*2;

Example :
StringBuffer sb =new StringBuffer(); // default constructor
System.out.println(sb.capacity());// 16
sb.append("GANTILAKSHMIHARIKA");
System.out.println(sb.capacity());//34

sb.append("GANTILAKSHMIHARIKAtejasandeep");
System.out.println(sb.capacity());//70 

sb.append("GANTILAKSHMIHARIKAtejasandeepravisurya");
System.out.println(sb.capacity());//142

StringBuffer sb =new StringBuffer(int 10000);//assigning inital capacity
System.out.println(sb.capacity());//10000


Initial Capacity Rule : (c  + length(string))
  StringBuffer love =new StringBuffer("Harika");
  System.out.println(love.capacity()); // 22 based on initial capacity rule 


lenth()
capacity()
charAt(int index)
setCharAt(int index , char newchar) :  StringBuffer mode = new StringBuffer("JAVA");
                                       mode.setCharAt(0, 'R');
                                       System.out.println(mode);

                              
insert() : 
        StringBuffer rava = new StringBuffer("naturalstar");
        rava.insert(0,"pakka");
        System.out.println(rava);// pakkanaturalstar
delete() : 
        StringBuffer lava = new StringBuffer("naturalstar");
        lava.delete(1, 5);
        System.out.println(lava);//nalstar
deleteCharAt(): 
        StringBuffer  v = new StringBuffer("Pakkasuperstar");
        v.deleteCharAt(8);
        System.out.println(v);//Pakkasuprstar

revers(): 
       StringBuffer h = new StringBuffer("opps");
        h.reverse();
        System.out.println(h); //sppo


  STRINGBUFFER                                                       STRINGBUILDER
 
  almost every method gets syinchronized                          No method gets synchronized.
  only one thread is allowed on sb object thread safe             NO thread safety
  Introduced in 1.0 version                                       Introduced in 1.5 version



  Method Chaining 
 method calls will be executed from left to right .
 example :
 StringBuilder sss = new StringBuilder("Harika");
        sss.append("sandeep").append('s').insert(0,"pakka").reverse();
        System.out.println(sss); // speednasakiraHakkap
    


// Static and non static 
 
 Static in java is mainly used for memory allocation beacuse in java there is a problem for memory allocation when objects are created so they created the static
 functionality in the main method when they are desigining.

 in class main method will be executed in program until if there is any block like static block  static block will execute first.


 static : no object creation is required.
 non static : object creation is required.
 

 OOPS IN JAVA
 Inheritance:
 one class can aquire the properties and behaviour of another class is called inheritance.


